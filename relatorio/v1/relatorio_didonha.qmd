---
title: "Cirurgias Dermatol√≥gicas em Nonagen√°rios"
subtitle: '"Nonagen√°rios" me lembra "nona", que me lembra "pic√£o da nona" üíñ'
author: "Jinfy Maria dos Santos Goedert"
date: today
date-format: "DD.MM.YYYY"
lang: pt-BR
format:
  html:
    theme: cosmo
    toc: false
    toc-depth: 3
    toc-location: left
    toc-title: "Navega√ß√£o"
    number-sections: true
    code-fold: true
    code-summary: "Ver c√≥digo"
    fig-width: 8
    fig-height: 5
    fig-dpi: 150
execute:
  echo: false
  warning: false
  message: false
  freeze: false
  cache: false
---

```{r}
#| label: setup
#| include: false

# Depend√™ncias
library(dplyr)
library(tidyr)
library(stringr)
library(forcats)
library(ggplot2)
library(gtsummary)
library(gt)
library(scales)
library(purrr)
library(tibble)
library(htmltools)
library(flextable)

# ---- Raiz do projeto (renv_root) ----
find_project_root <- function(start = getwd(), marker = "90gen.Rproj", max_up = 15) {
  p <- normalizePath(start, winslash = "/", mustWork = FALSE)
  for (i in 0:max_up) {
    if (file.exists(file.path(p, marker))) return(p)
    up <- normalizePath(file.path(p, ".."), winslash = "/", mustWork = FALSE)
    if (identical(up, p)) break
    p <- up
  }
  normalizePath(start, winslash = "/", mustWork = FALSE)
}

proj <- Sys.getenv("QUARTO_PROJECT_DIR", unset = getwd())
renv_root <- find_project_root(proj)

# opcional: garantir que achou mesmo o 90gen (para falhar com mensagem boa)
if (!file.exists(file.path(renv_root, "90gen.Rproj"))) {
  stop("N√£o encontrei a raiz do projeto (90gen.Rproj) subindo a partir de: ", proj)
}

# Dados
pacientes_path <- file.path(renv_root, "data", "derived", "pacientes.rds")
lesoes_path    <- file.path(renv_root, "data", "derived", "lesoes.rds")

stopifnot(file.exists(pacientes_path), file.exists(lesoes_path))

pacientes <- readRDS(pacientes_path)
lesoes    <- readRDS(lesoes_path)

# Tema global para gr√°ficos
theme_set(
  theme_minimal(base_size = 12) +
    theme(
      plot.title = element_text(face = "bold", size = 14),
      plot.subtitle = element_text(color = "gray40"),
      panel.grid.minor = element_blank(),
      legend.position = "bottom"
    )
)

# Fun√ß√£o para formatar n (percentual)
fmt_npct <- function(k, n) sprintf("%d (%.1f%%)", k, 100 * k / n)

# Paleta de cores
cores <- c(
  cbc = "#2E86AB",
  cec = "#A23B72",
  fem = "#E85D75",
  masc = "#4A90A4"
)
```

# Disclaimer

Hello didi, t√¥ tentando fazer a an√°lise de jeito que d√™ pra ver o que est√° acontecendo (e j√° ir pensando junto no que isso significa pro teu trabalho).

**O que temos em m√µes:**

-   **`r nrow(pacientes)` pacientes** no total
-   **`r nrow(lesoes)` les√µes** operadas no total

Eu no come√ßo pensava que com um n baixo n√£o teria teste estat√≠stico, p-valor, intervalo de confian√ßa... Mas eu fui testar como quem n√£o quer nada e... p \< 0.01

De qualquer forma acho que o mais importante pro teu trabalho agora √© a an√°lise descritiva

------------------------------------------------------------------------

# Quem s√£o esses velhos?

## O b√°sico: idade, sexo, fototipo

```{r}
#| label: tbl-demografica
#| tbl-cap: "Caracter√≠sticas dos pacientes"

df_tab <- pacientes |>
  mutate(
    sexo_label = factor(sexo, c("f", "m"), c("Feminino", "Masculino")),
    fototipo = factor(fototipo)
  )

tbl_idade_gts <- df_tab |>
  select(idade) |>
  tbl_summary(
    label = list(idade ~ "Idade (anos)"),
    statistic = list(all_continuous() ~ "{median} ({p25}‚Äì{p75})"),
    digits = list(all_continuous() ~ 1),
    missing = "no"
  )

tbl_outros_gts <- df_tab |>
  select(sexo_label, fototipo, cbc_cec_previo, mohs, mais_cx, obito) |>
  tbl_summary(
    label = list(
      sexo_label ~ "Sexo",
      fototipo ~ "Fototipo (Fitzpatrick)",
      cbc_cec_previo ~ "J√° teve CBC/CEC antes",
      mohs ~ "Fez Mohs",
      mais_cx ~ "Teve outras cirurgias",
      obito ~ "Faleceu no seguimento"
    ),
    statistic = list(all_categorical() ~ "{n} ({p}%)"),
    digits = list(all_categorical() ~ c(0, 1)),
    missing = "no"
  )

tbl_idade_gt <- tbl_idade_gts |>
  bold_labels() |>
  as_gt()

tbl_outros_gt <- tbl_outros_gts |>
  bold_labels() |>
  as_gt()

tbl_idade_docx <- tbl_idade_gts |>
  bold_labels() |>
  as_flex_table()

tbl_outros_docx <- tbl_outros_gts |>
  bold_labels() |>
  as_flex_table()

# Mosaico lado a lado (HTML); em docx, imprime em sequencia
if (knitr::is_html_output()) {
  htmltools::div(
    style = "display:flex; gap:18px; align-items:flex-start;",
    htmltools::div(
      style = "flex: 0 0 32%;",
      htmltools::HTML(gt::as_raw_html(tbl_idade_gt))
    ),
    htmltools::div(
      style = "flex: 1 1 68%;",
      htmltools::HTML(gt::as_raw_html(tbl_outros_gt))
    )
  )
} else {
  tbl_idade_docx
  tbl_outros_docx
}
```

```{r}
#| label: fig-idade
#| fig-cap: "Distribui√ß√£o de idade"

pacientes |>
  ggplot(aes(x = idade)) +
  geom_histogram(binwidth = 1, fill = cores["cbc"], color = "white", alpha = 0.8) +
  geom_vline(
    xintercept = median(pacientes$idade),
    linetype = "dashed", color = "gray30", linewidth = 0.8
  ) +
  annotate(
    "text",
    x = median(pacientes$idade) + 0.5,
    y = Inf, vjust = 2, hjust = 0,
    label = paste0("Mediana: ", median(pacientes$idade), " anos"),
    size = 3.5, color = "gray30"
  ) +
  scale_x_continuous(breaks = seq(90, 110, 2)) +
  labs(
    x = "Idade (anos)",
    y = "N√∫mero de pacientes",
    title = "A idade dos teus pacientes",
    subtitle = "Todo mundo tem 90+, mas olha a varia√ß√£o!"
  )
```

Olha que interessante: a [mediana](#nota-definicoes) √© `r median(pacientes$idade)` anos. Isso significa que metade dos teus pacientes tem **mais** que isso. √â uma popula√ß√£o bem idosa mesmo ‚Äî o que faz total sentido pro teu recorte.

::: callout-note
## Por que vamos usar mediana e n√£o m√©dia?

~~Gata, eu tamb√©m consigo aparecer em forma de bal√£ozinho. Sou muito foda~~

Sim, eu tamb√©m gosto da **m√©dia**. Ela √© um √≥timo resumo estat√≠stico quando os dados s√£o sim√©tricos (ou seja, quando os valores giram em torno de um ponto central).

S√≥ que como d√° pra ver no @fig-idade, a nossa amostra √© assim√©trica (d√° pra ver direitinho que a maior massa de pacientes t√° √† esquerda), e isso distorce a m√©dia. Por esse motivo, ela n√£o √© a primeira linha no nosso caso.

A **mediana**, n√£o sei se tu lembra, √© exatamente o valor que divide a amostra em duas metades iguais. Metade dos pacientes tem idade menor que a mediana, e metade maior. Ela acaba sendo bem mais robusta quando a gente lida com valores extremos (tipo um paciente com 110 anos) e d√° uma ideia melhor do "centro" quando os dados n√£o se comportam de um jeito "bonitinho" em torno do centro.
:::

## E as comorbidades?

Quase ningu√©m chega nos 90 "zerado", n√©?

```{r}
#| label: fig-comorbidades
#| fig-cap: "As comorbidades mais comuns"

comorb_cols <- c("has", "dm", "dlp", "ic", "fa", "drc", "alzheimer", "parkinson", "dpoc")
comorb_labels <- c(
  has = "Hipertens√£o", dm = "Diabetes", dlp = "Dislipidemia",
  ic = "Insuf. card√≠aca", fa = "Fibrila√ß√£o atrial", drc = "Doen√ßa renal cr√¥nica",
  alzheimer = "Alzheimer", parkinson = "Parkinson", dpoc = "DPOC"
)

comorb_prev <- pacientes |>
  summarise(across(all_of(comorb_cols), ~ sum(.x, na.rm = TRUE))) |>
  pivot_longer(everything(), names_to = "comorbidade", values_to = "n") |>
  mutate(
    pct = n / nrow(pacientes) * 100,
    label = comorb_labels[comorbidade],
    label = fct_reorder(label, pct)
  )

comorb_prev |>
  ggplot(aes(x = label, y = pct)) +
  geom_col(fill = cores["cbc"], width = 0.7) +
  geom_text(aes(label = sprintf("%.0f%%", pct)), hjust = -0.2, size = 3.5) +
  coord_flip() +
  scale_y_continuous(limits = c(0, 100), labels = \(x) paste0(x, "%")) +
  labs(
    x = NULL,
    y = "Preval√™ncia",
    title = "O que eles t√™m al√©m do c√¢ncer de pele",
    subtitle = "Spoiler: hipertens√£o lidera disparado"
  )
```

A **hipertens√£o** √© a doen√ßa mais frequente na nossa popula√ß√£o, o que choca um total de *zero pessoas*. Mas repara na quantidade de comorbidades cardiovasculares e neurol√≥gicas. Isso pode ser um ponto interessante pra discuss√£o ‚Äî essa popula√ß√£o n√£o √© a mais tranquila de operar.

## Carga de comorbidades

```{r}
#| label: fig-carga-comorbidades
#| fig-cap: "Carga de comorbidades por paciente (n√∫mero de comorbidades por indiv√≠duo)."

comorb_cols <- c("has", "dm", "dlp", "ic", "fa", "drc", "alzheimer", "parkinson", "dpoc")
comorb_cols <- intersect(comorb_cols, names(pacientes))
stopifnot(length(comorb_cols) > 0)

carga <- pacientes |>
  mutate(
    n_comorb = rowSums(across(all_of(comorb_cols), ~ as.integer(.x %in% TRUE)), na.rm = TRUE)
  )

carga |>
  count(n_comorb, name = "n") |>
  mutate(pct = n / sum(n) * 100) |>
  ggplot(aes(x = factor(n_comorb), y = pct)) +
  geom_col(fill = cores["cbc"], width = 0.7) +
  geom_text(aes(label = sprintf("%.0f%%", pct)), vjust = -0.3, size = 3.5) +
  labs(
    x = "N√∫mero de comorbidades",
    y = "Propor√ß√£o de pacientes",
    title = "Carga de comorbidades (contagem bruta)",
    subtitle = "0, 1, 2, 3‚Ä¶ comorbidades por paciente"
  )
```

Aqui eu coloquei o n√∫mero de comorbidades pra ver qu√£o doente a popula√ß√£o √© al√©m do c√¢ncer de pele. O que d√° pra tirar daqui: n√£o √© uma amostra "limpa"... Tem uns sem comorbidades, e outros com uma caralhada de doen√ßas. Acredito que isso importa porque costuma aumentar o risco de complica√ß√µes, cicatriza√ß√£o mais lenta, infec√ß√£o etc. √â uma carga razo√°vel de comorbidades.

```{r}
#| label: fig-carga-comorbidades-classe
#| fig-cap: "Carga de comorbidades por grupos de doen√ßas"

classes_tbl <- tribble(
  ~classe,           ~cols,
  "Cardiovascular",  c("has", "dac", "ic", "fa", "avc", "ivc", "arritmia", "dlp"),
  "Metab√≥lica",      c("dm", "hipotir", "hipertir"),
  "Respirat√≥ria",    c("dpoc", "asma"),
  "Neuropsiqui√°trica", c("alzheimer", "parkinson", "epilepsia", "depressao", "ansiedade", "esquizofrenia"),
  "Renal",           c("drc"),
  "Oncol√≥gica",      c("cbc_cec_previo", "leucemia", "mm", "ca_prostata", "ca_rim", "ca_laringe"),
  "H√°bitos",         c("tabagismo", "etilismo", "ex-tabag")
)

# Mant√©m s√≥ colunas que existem no dataframe
classes_tbl2 <- classes_tbl %>%
  mutate(cols = map(cols, ~ intersect(.x, names(pacientes)))) %>%
  filter(map_int(cols, length) > 0)

classes_map <- stats::setNames(classes_tbl2$cols, classes_tbl2$classe)

prev_classe <- classes_tbl2 %>%
  mutate(
    tem = map(cols, ~ {
      # TRUE se o paciente tem >=1 condi√ß√£o na classe
      rowSums(pacientes[, .x, drop = FALSE] %>%
                mutate(across(everything(), ~ as.integer(.x %in% TRUE))),
              na.rm = TRUE) > 0
    })
  ) %>%
  transmute(
    classe,
    n = map_int(tem, ~ sum(.x, na.rm = TRUE)),
    pct = 100 * n / nrow(pacientes)
  )

prev_classe %>%
  mutate(classe = fct_reorder(classe, pct)) %>%
  ggplot(aes(x = classe, y = pct)) +
  geom_col(fill = cores["cbc"], width = 0.7) +
  geom_text(aes(label = sprintf("%.0f%%", pct)), hjust = -0.2, size = 3.5) +
  coord_flip() +
  scale_y_continuous(limits = c(0, 100), labels = \(x) paste0(x, "%")) +
  labs(
    x = NULL,
    y = "Preval√™ncia",
    title = "Comorbidades por grandes classes de doen√ßas",
    subtitle = "(defini√ß√£o de classe: tem pelo menos 1 condi√ß√£o do grupo)"
  )
```

```{r}
#| label: fig-carga-classes-comorbidas
#| fig-cap: "Carga de classes com√≥rbidas"
classe_flags <- purrr::imap_dfc(classes_map, \(cols, classe) {
  if (length(cols) == 0) return(NULL)

  tem <- rowSums(pacientes[, cols, drop = FALSE] %>% 
                   mutate(across(everything(), ~ as.integer(.x %in% TRUE))),
                 na.rm = TRUE) > 0

  tibble::tibble(!!paste0("classe_", stringr::str_to_lower(classe)) := tem)
})

pacientes_classes <- bind_cols(pacientes, classe_flags) %>%
  mutate(
    n_classes = rowSums(across(starts_with("classe_"), ~ as.integer(.x %in% TRUE)), na.rm = TRUE)
  )

pacientes_classes %>%
  count(n_classes) %>%
  mutate(pct = n / sum(n) * 100) %>%
  ggplot(aes(x = factor(n_classes), y = pct)) +
  geom_col(fill = cores["cbc"], width = 0.7) +
  geom_text(aes(label = sprintf("%.0f%%", pct)), vjust = -0.3, size = 3.5) +
  labs(
    x = "N√∫mero de classes comorbidas",
    y = "Propor√ß√£o de pacientes",
    title = "Multimorbidade por classes",
    subtitle = "Quantas √°reas do corpo est√£o ‚Äúenvolvidas‚Äù por comorbidades?"
  )
```

## Quantas les√µes por paciente?

Aqui tem um detalhe metodol√≥gico importante:

```{r}
#| label: tbl-carga-lesoes
#| fig-cap: "N√∫mero de les√µes para cada paciente"

lesoes_por_pac <- lesoes |>
  count(paciente, name = "n_lesoes") |>
  count(n_lesoes, name = "n_pacientes") |>
  mutate(
    pct = n_pacientes / sum(n_pacientes) * 100,
    pct_fmt = sprintf("%.1f%%", pct)
  )

lesoes_por_pac |>
  select(`Les√µes` = n_lesoes, `Pacientes` = n_pacientes, `%` = pct_fmt) |>
  gt() |>
  tab_header(
    title = "Quantas les√µes cada paciente teve?",
    subtitle = "A maioria tem uma, mas tem gente com v√°rias"
  ) |>
  cols_align(align = "center")
```

```{r}
#| label: calcula-multiplas

n_multiplas <- sum(lesoes_por_pac$n_pacientes[lesoes_por_pac$n_lesoes > 1])
pct_multiplas <- n_multiplas / nrow(pacientes) * 100
```

`r n_multiplas` pacientes (quase metade, `r sprintf("%.1f", pct_multiplas)`%) t√™m mais de uma les√£o.

------------------------------------------------------------------------

# Les√µes: protagonistas, coadjuvantes e participa√ß√µes especiais

Agora olhando pras les√µes em si o n engorda (s√£o 111!!!)

::: callout-note
## Ponto de aten√ß√£o

Quando a gente for fazer an√°lise estat√≠stica les√£o por les√£o, essas les√µes do mesmo paciente n√£o s√£o independentes. O mesmo paciente que teve uma complica√ß√£o na ex√©rese de uma les√£o pode ter predisposi√ß√£o a ter complica√ß√µes em outra. Agora eu t√¥ com pregui√ßa, mas a gente vai ter que pensar nisso mais tarde
:::

## CBC ou CEC?

```{r}
#| label: fig-tipo-histo
#| fig-cap: "A divis√£o b√°sica: CBC vs CEC"

lesoes |>
  filter(!is.na(histo_tipo)) |>
  count(histo_tipo) |>
  mutate(
    pct = n / sum(n),
    label_pct = scales::percent(pct, accuracy = 0.1),
    label = toupper(histo_tipo),
    label = fct_reorder(label, n, .desc = TRUE)
  ) |>
  ggplot(aes(x = label, y = n, fill = histo_tipo)) +
  geom_col(width = 0.5) +
  geom_text(
    aes(label = label_pct),
    position = position_stack(vjust = 0.5),
    color = "white", fontface = "bold", size = 4
  ) +
  geom_text(
    aes(label = n),
    vjust = -0.4,
    color = "gray20",
    fontface = "bold",
    size = 4
  ) +
  scale_fill_manual(values = cores[c("cbc", "cec")], guide = "none") +
  scale_y_continuous(expand = expansion(mult = c(0, 0.12))) +
  labs(
    x = NULL,
    y = "N√∫mero de les√µes",
    title = "CBC domina, como esperado",
    subtitle = paste0("Total: ", nrow(lesoes), " les√µes")
  )
```

```{r}
#| label: calc-tipos
pct_cbc <- mean(lesoes$histo_tipo == "cbc", na.rm = TRUE) * 100
pct_cec <- mean(lesoes$histo_tipo == "cec", na.rm = TRUE) * 100
```

CBC representa `r sprintf("%.0f", pct_cbc)`% das les√µes. O basocelular √© o mais comum mesmo (eu li na Wikip√©dia), mas os `r sprintf("%.0f", pct_cec)`% de CEC s√£o mais agressivos (fonte: ChatGPT)

## Os subtipos do CBC

Isso aqui √© babado pra discuss√£o

```{r}
#| label: fig-subtipos-cbc
#| fig-cap: "Quais subtipos de CBC aparecem?"

lesoes |>
  filter(histo_tipo == "cbc", !is.na(histo_subtipo), histo_subtipo != "") |>
  separate_rows(histo_subtipo, sep = ", ") |>
  count(histo_subtipo) |>
  mutate(histo_subtipo = fct_reorder(histo_subtipo, n)) |>
  ggplot(aes(x = histo_subtipo, y = n)) +
  geom_col(fill = cores["cbc"], width = 0.7) +
  geom_text(aes(label = n), hjust = -0.3, size = 3.5) +
  coord_flip() +
  scale_y_continuous(expand = expansion(mult = c(0, 0.15))) +
  labs(
    x = NULL,
    y = "Frequ√™ncia",
    title = "Subtipos histol√≥gicos do CBC",
    subtitle = "Nodular lidera, mas tem bastante infiltrativo tamb√©m"
  )
```

**Nodular** √© o mais comum. Mas tem uma quantidade razo√°vel de **infiltrativo** e **s√≥lido** ‚Äî esses s√£o os que d√£o mais trabalho, com margens mal definidas.

::: callout-note
## Sobre o NA

Tem uma les√£o que n√£o tem subtipo registrado, mas d√° pra filtrar fora do gr√°fico oficial
:::

Isso pode render uma tabela 2x2: ser√° que os subtipos mais agressivos t√™m mais margem comprometida?

## CECs: quem s√£o, onde est√£o e como se apresentam

```{r}
#| label: tbl-cec-comportamento
#| tbl-cap: "Caracter√≠sticas do CEC"

n_cec <- sum(lesoes$histo_tipo == "cec", na.rm = TRUE)

lesoes |>
  filter(histo_tipo == "cec") |>
  select(histo_difer, comport) |>
  tbl_summary(
    label = list(
      histo_difer ~ "Diferencia√ß√£o",
      comport ~ "Comportamento"
    ),
    statistic = all_categorical() ~ "{n} ({p}%)",
    missing_text = "N√£o especificado"
  ) |>
  bold_labels() |>
  as_gt() |>
  tab_header(
    title = "O perfil dos CECs",
    subtitle = paste0("N = ", n_cec, " les√µes")
  )
```

## LOcal das les√µes

```{r}
#| label: fig-localizacao
#| fig-cap: "Mapa anat√¥mico das les√µes"

lesoes_local <- lesoes |>
  mutate(
    local_grupo = case_when(
      localizacao == "face" ~ "Face",
      localizacao == "orelha" ~ "Orelha",
      localizacao == "couro cabeludo" ~ "Couro cabeludo",
      localizacao %in% c("t√≥rax", "dorso") ~ "Tronco",
      localizacao == "cervical" ~ "Cervical",
      str_detect(localizacao, "membro superior|antebra√ßo") ~ "Membro superior",
      str_detect(localizacao, "membro inferior|p√©") ~ "Membro inferior",
      TRUE ~ "Outro"
    ),
    histo_tipo = tolower(histo_tipo)
  )

lesoes_local |>
  filter(!is.na(local_grupo), histo_tipo %in% c("cbc", "cec")) |>
  count(local_grupo, histo_tipo, name = "n") |>
  mutate(
    local_grupo = fct_reorder(local_grupo, n, .fun = sum),
    histo_tipo = factor(histo_tipo, levels = c("cbc", "cec"))
  ) |>
  ggplot(aes(x = local_grupo, y = n, fill = histo_tipo)) +
  geom_col(width = 0.7) +
  geom_text(
    aes(label = n),
    position = position_stack(vjust = 0.5),
    color = "white", fontface = "bold", size = 3.5
  ) +
  coord_flip() +
  scale_fill_manual(
    values = cores[c("cbc", "cec")],
    labels = c("cbc" = "CBC", "cec" = "CEC"),
    name = "Tipo"
  ) +
  labs(
    x = NULL,
    y = "N√∫mero de les√µes",
    title = "Onde est√£o as les√µes?",
    subtitle = "Face e orelha dominam ‚Äî faz sentido, s√£o √°reas fotoexpostas"
  )
```

Sem surpresas, n√©? Agora sobre esses n√∫meros malucos nem me pergunte, o R colocou sozinho mas vou tirar depois

------------------------------------------------------------------------

# Como voc√™s fecharam?

## T√©cnicas utilizadas

```{r}
#| label: tbl-fechamento
#| tbl-cap: "T√©cnicas de fechamento"

lesoes_fech <- lesoes |>
  filter(!is.na(fech)) |>
  mutate(
    fech_label = case_when(
      fech == "direto" ~ "Fechamento direto",
      fech == "retalho" ~ "Retalho",
      fech == "enxerto" ~ "Enxerto",
      fech == "2intencao" ~ "Segunda inten√ß√£o",
      TRUE ~ fech
    ),
    tipo = toupper(histo_tipo)
  ) |>
  select(fech_label, tipo)

N_fech <- nrow(lesoes_fech)
N_cbc  <- sum(lesoes_fech$tipo == "CBC", na.rm = TRUE)
N_cec  <- sum(lesoes_fech$tipo == "CEC", na.rm = TRUE)

fech_levels <- c("Fechamento direto", "Enxerto", "Retalho", "Segunda inten√ß√£o")

tbl_fech <- tibble::tibble(Tecnica = fech_levels) |>
  rowwise() |>
  mutate(
    n_cbc = sum(lesoes_fech$tipo == "CBC" & lesoes_fech$fech_label == Tecnica, na.rm = TRUE),
    n_cec = sum(lesoes_fech$tipo == "CEC" & lesoes_fech$fech_label == Tecnica, na.rm = TRUE),
    n_total = n_cbc + n_cec
  ) |>
  ungroup() |>
  mutate(
    CBC = fmt_npct(n_cbc, N_cbc),
    CEC = fmt_npct(n_cec, N_cec),
    Total = fmt_npct(n_total, N_fech)
  ) |>
  select(Tecnica, CBC, CEC, Total)

n_row <- tibble::tibble(
  Tecnica = "N",
  CBC = as.character(N_cbc),
  CEC = as.character(N_cec),
  Total = as.character(N_fech)
)

tbl_out <- dplyr::bind_rows(tbl_fech, n_row)

tbl_out |>
  gt() |>
  tab_header(
    title = "Como fecharam as feridas?",
    subtitle = "Por tipo histol√≥gico"
  ) |>
  tab_spanner(
    label = "Histologia",
    columns = c(CBC, CEC, Total)
  ) |>
  cols_label(
    Tecnica = "T√©cnica",
    CBC = "CBC",
    CEC = "CEC",
    Total = "Total"
  ) |>
  cols_align("left", columns = "Tecnica") |>
  cols_align("center", columns = c("CBC", "CEC", "Total"))
```

Fechamento direto √© o mais comum ‚Äî faz sentido, √© o mais simples quando d√°. Mas tem bastante retalho e enxerto tamb√©m, o que mostra que as les√µes n√£o eram todas triviais.

**Pergunta que pode surgir:** ser√° que a t√©cnica de fechamento influencia a taxa de complica√ß√£o? (spoiler: provavelmente sim, mas a gente vai ver isso na an√°lise inferencial)

------------------------------------------------------------------------

# Os desfechos: o que aconteceu?

## Margens cir√∫rgicas

```{r}
#| label: fig-margens
#| fig-cap: "Resultado das margens"

lesoes |>
  filter(!is.na(margens_ap)) |>
  mutate(
    margens_status = case_when(
      str_detect(margens_ap, "comprometida") ~ "Comprometidas",
      margens_ap == "livres" ~ "Livres",
      TRUE ~ "Outro"
    )
  ) |>
  count(margens_status) |>
  mutate(
    pct = n / sum(n) * 100,
    margens_status = fct_reorder(margens_status, n, .desc = TRUE)
  ) |>
  ggplot(aes(x = margens_status, y = n, fill = margens_status)) +
  geom_col(width = 0.5) +
  geom_text(
    aes(label = sprintf("%d (%.1f%%)", n, pct)),
    vjust = -0.3, size = 4
  ) +
  scale_fill_manual(
    values = c("Livres" = "#2A9D8F", "Comprometidas" = "#E63946", "Outro" = "gray60"),
    guide = "none"
  ) +
  scale_y_continuous(expand = expansion(mult = c(0, 0.15))) +
  labs(
    x = NULL,
    y = "N√∫mero de les√µes",
    title = "As margens ficaram livres?",
    subtitle = "Esse √© um dos desfechos mais importantes"
  )
```

```{r}
#| label: calc-margens
pct_livres <- lesoes |>
  filter(!is.na(margens_ap)) |>
  summarise(pct = mean(margens_ap == "livres", na.rm = TRUE) * 100) |>
  pull(pct)
```

A maioria das margens veio livre ‚Äî isso √© bom! Mas tem `r sprintf("%.1f", 100 - pct_livres)`% de margens comprometidas ou parcialmente comprometidas.

Esses casos devem estar ligados diretamente √† reinterven√ß√£o ou acompanhamento mais pr√≥ximo. Pode ser interessante ver se tem algum padr√£o: tipo histol√≥gico, localiza√ß√£o, subtipo...

## Complica√ß√µes e reinterven√ß√µes

```{r}
#| label: tbl-desfechos
#| tbl-cap: "Desfechos adversos"

lesoes |>
  mutate(
    teve_complicacao = !is.na(complicacao) & complicacao != "",
    teve_reintervencao = reintervencao == TRUE
  ) |>
  select(teve_complicacao, teve_reintervencao) |>
  tbl_summary(
    label = list(
      teve_complicacao ~ "Teve complica√ß√£o",
      teve_reintervencao ~ "Precisou reintervir"
    ),
    statistic = all_categorical() ~ "{n} ({p}%)"
  ) |>
  bold_labels() |>
  as_gt() |>
  tab_header(
    title = "Deu problema?",
    subtitle = paste0("N = ", nrow(lesoes), " les√µes")
  )
```

```{r}
#| label: fig-complicacoes
#| fig-cap: "Tipos de complica√ß√£o"

complicacoes <- lesoes |>
  filter(!is.na(complicacao), complicacao != "") |>
  separate_rows(complicacao, sep = ",\\s*") |>
  count(complicacao) |>
  filter(n > 0)

if (nrow(complicacoes) > 0) {
  complicacoes |>
    mutate(complicacao = fct_reorder(complicacao, n)) |>
    ggplot(aes(x = complicacao, y = n)) +
    geom_col(fill = "#E63946", width = 0.6) +
    geom_text(aes(label = n), hjust = -0.3, size = 4) +
    coord_flip() +
    scale_y_continuous(expand = expansion(mult = c(0, 0.2))) +
    labs(
      x = NULL,
      y = "Casos",
      title = "Quando complicou, o que foi?",
      subtitle = "Os tipos de complica√ß√£o observados"
    )
} else {
  cat("Boa not√≠cia: nenhuma complica√ß√£o registrada!")
}
```

Um dos desfechos mais foda do teu trabalho: perfil de seguran√ßa do procedimento nos 90+. Gente velha, com v√°rias comorbidades, mas mesmo assim a taxa de complica√ß√£o √© relativamente baixa.

------------------------------------------------------------------------

# Checando a consist√™ncia dos dados

Antes de a gente confiar 100% nos dados, deixa eu te mostrar uma verifica√ß√£o r√°pida:

```{r}
#| label: tbl-consistencia
#| tbl-cap: "Atributos por tipo histol√≥gico"

# ---- helpers ----
fmt_npct <- function(k, n) sprintf("%d (%.1f%%)", k, 100 * k / n)
indent <- function(x, n = 6) paste0(strrep("\u00A0", n), x)

# ---- dados (autossuficiente) ----
col_comp_txt <- "complicacao"  # ajusta se for outro nome

lesoes_fix <- lesoes %>%
  mutate(
    complicacoes_txt = str_squish(as.character(.data[[col_comp_txt]])),
    complicacoes_txt = na_if(complicacoes_txt, ""),
    teve_complicacao = !is.na(complicacoes_txt),

    reintervencao = as.logical(reintervencao),
    reintervencao = if_else(is.na(reintervencao), FALSE, reintervencao),

    sem_intercorrencias = !teve_complicacao & !reintervencao
  )

n_total <- nrow(lesoes_fix)

# ---- linhas principais ----
main <- tibble(
  Grupo = c("Complica√ß√£o", "Reinterven√ß√£o", "Sem intercorr√™ncias"),
  n = c(
    sum(lesoes_fix$teve_complicacao),
    sum(lesoes_fix$reintervencao),
    sum(lesoes_fix$sem_intercorrencias)
  )
) %>%
  mutate(`n (%)` = fmt_npct(n, n_total)) %>%
  select(Grupo, `n (%)`)

# ---- tipos de complica√ß√£o ----
comp_types <- lesoes_fix %>%
  filter(!is.na(complicacoes_txt)) %>%
  mutate(complicacoes_txt = str_to_lower(complicacoes_txt)) %>%
  separate_rows(complicacoes_txt, sep = "\\s*,\\s*") %>%
  mutate(complicacoes_txt = str_squish(complicacoes_txt)) %>%
  filter(complicacoes_txt != "") %>%
  count(complicacoes_txt, sort = TRUE, name = "n") %>%
  mutate(
    Grupo = indent(str_to_sentence(complicacoes_txt)),
    `n (%)` = fmt_npct(n, n_total)
  ) %>%
  select(Grupo, `n (%)`)

tab <- bind_rows(
  main %>% slice(1),
  comp_types,
  main %>% slice(2:3)
)

# ---- tabela ----
tab %>%
  gt() %>%
  tab_header(
    title = "Complica√ß√µes e reinterven√ß√µes",
    subtitle = sprintf("N = %d les√µes", n_total)
  ) %>%
  cols_label(
    Grupo = "Eventos adversos",
    `n (%)` = "n (%)"
  ) %>%
  cols_align("left", Grupo) %>%
  cols_align("right", `n (%)`) %>%
  tab_footnote(
    footnote = "Uma les√£o pode apresentar mais de um tipo de complica√ß√£o; por isso, as subcategorias podem somar mais do que o total de complica√ß√µes.",
    locations = cells_body(columns = Grupo, rows = 1)
  )
```

::: callout-warning
## Eu sou ignorante

Aqui eu ~~estudei uma revis√£o publicada no New England e li mais dois artigos do Lancet pra checar se a minha interpreta√ß√£o dos dados est√° correta~~ consultei o ChatGPT (eu espero que ele n√£o tenha alucinado)
:::

Pelo que entendi, certos atributos s√≥ fazem sentido pra certos tipos histol√≥gicos: - **CBC** deve ter subtipo (nodular, infiltrativo, etc.), n√£o diferencia√ß√£o - **CEC** deve ter diferencia√ß√£o e \*\*comportamento, n√£o subtipo

It's tricky

------------------------------------------------------------------------

# Resumo da √≥pera

```{r}
#| label: resumo-final

n_pac <- nrow(pacientes)
n_les <- nrow(lesoes)
idade_med <- median(pacientes$idade)
pct_fem <- mean(pacientes$sexo == "f", na.rm = TRUE) * 100
pct_cbc <- mean(lesoes$histo_tipo == "cbc", na.rm = TRUE) * 100
pct_complic <- mean(!is.na(lesoes$complicacao) & lesoes$complicacao != "", na.rm = TRUE) * 100
```

| O que               | Quanto                                   |
|---------------------|------------------------------------------|
| Pacientes           | `r n_pac`                                |
| Les√µes operadas     | `r n_les`                                |
| Idade mediana       | `r idade_med` anos                       |
| Mulheres            | `r sprintf("%.0f", pct_fem)`%            |
| CBC                 | `r sprintf("%.0f", pct_cbc)`% das les√µes |
| Taxa de complica√ß√£o | `r sprintf("%.1f", pct_complic)`%        |

------------------------------------------------------------------------

# Parte anal√≠tica (explorat√≥ria)

A ideia aqui n√£o √© ‚Äúca√ßar p-valor‚Äù, e sim tentar enxergar padr√µes promissores pra depois a gente cruzar as vari√°veis certas.

## Heatmaps

Se a gente tentasse testar estatisticamente todas as combina√ß√µes poss√≠veis, perder√≠amos poder estat√≠stico, encontrar√≠amos associa√ß√µes ao acaso... Al√©m de ser chato pra caralho. Pra resolver isso, a gente usa o *heatmap*: ele cruza as vari√°veis categ√≥ricas e devolve d√° uma matriz matem√°tica de correla√ß√µes (0 = nada a ver, 1 = tudooo) em intensidade visual. A interpreta√ß√£o √© simples: quanto mais o n√∫mero for pr√≥ximo de 1 (e a cor for mais intensa), existe uma rela√ß√£o matem√°tica mais forte entre as duas condi√ß√µes.

### *Heatmap* explorat√≥rio

Esse heatmap mostra **for√ßa de associa√ß√£o** entre vari√°veis categ√≥ricas (0 = nada a ver, 1 = tudoo). √â explorat√≥rio e n√£o ajusta a depend√™ncia de m√∫ltiplas les√µes por paciente ‚Äî mas j√° d√° um norte legal.

```{r}
#| label: fig-heatmap-associacoes
#| fig-cap: "Heatmap explorat√≥rio de associa√ß√µes entre vari√°veis (V de Cram√©r)."
#| fig-width: 9
#| fig-height: 7

# --- dataset anal√≠tico (n√≠vel: les√£o) ---
fech_levels <- c("Fechamento direto", "Enxerto", "Retalho", "Segunda inten√ß√£o")

lesoes_ana <- lesoes |>
  mutate(
    # Tipo histol√≥gico (CBC/CEC)
    tipo = factor(tolower(histo_tipo), levels = c("cbc", "cec")),

    # Local (grupo anat√¥mico) ‚Äì mesmo esp√≠rito do fig-localizacao
    local_grupo = case_when(
      localizacao == "face" ~ "Face",
      localizacao == "orelha" ~ "Orelha",
      localizacao == "couro cabeludo" ~ "Couro cabeludo",
      localizacao %in% c("t√≥rax", "dorso") ~ "Tronco",
      localizacao == "cervical" ~ "Cervical",
      str_detect(localizacao, "membro superior|antebra√ßo") ~ "Membro superior",
      str_detect(localizacao, "membro inferior|p√©") ~ "Membro inferior",
      TRUE ~ "Outro"
    ) |> factor(),

    # T√©cnica de fechamento (label bonitinho)
    fech_label = case_when(
      fech == "direto" ~ "Fechamento direto",
      fech == "retalho" ~ "Retalho",
      fech == "enxerto" ~ "Enxerto",
      fech == "2intencao" ~ "Segunda inten√ß√£o",
      TRUE ~ as.character(fech)
    ) |> factor(levels = fech_levels),

    # Margens
    margens_status = case_when(
      is.na(margens_ap) ~ NA_character_,
      str_detect(margens_ap, "comprometida") ~ "Comprometidas",
      margens_ap == "livres" ~ "Livres",
      TRUE ~ "Outro"
    ) |> factor(levels = c("Livres", "Comprometidas", "Outro")),

    # Desfechos bin√°rios
    teve_complicacao = !is.na(complicacao) & str_squish(as.character(complicacao)) != "",
    teve_reintervencao = as.logical(reintervencao) %in% TRUE
  )

# Vari√°veis candidatas ao heatmap
vars <- c(
  "tipo",
  "local_grupo",
  "fech_label",
  "margens_status",
  "teve_complicacao",
  "teve_reintervencao"
)

# Padroniza l√≥gicos para fator (Sim/N√£o)
lesoes_ana2 <- lesoes_ana |>
  mutate(
    across(
      all_of(c("teve_complicacao", "teve_reintervencao")),
      ~ factor(.x, levels = c(FALSE, TRUE), labels = c("N√£o", "Sim"))
    )
  ) |>
  select(all_of(vars))

# Remove vari√°veis "mudas" (poucos dados/sem varia√ß√£o), pra n√£o sobrar linha/coluna em branco
var_ok <- purrr::map_lgl(vars, function(v) {
  x <- lesoes_ana2[[v]]
  x <- x[!is.na(x)]
  length(x) >= 10 && dplyr::n_distinct(x) >= 2
})

vars2 <- vars[var_ok]

vars_drop <- setdiff(vars, vars2)
if (length(vars_drop) > 0) {
  message(
    "Vari√°veis removidas do heatmap por dados insuficientes/sem varia√ß√£o: ",
    paste(vars_drop, collapse = ", ")
  )
}

stopifnot(length(vars2) >= 2)

# V de Cram√©r (tamanho de efeito) para duas vari√°veis categ√≥ricas
cramers_v <- function(x, y) {
  tab <- table(x, y, useNA = "no")
  if (nrow(tab) < 2 || ncol(tab) < 2) return(NA_real_)

  chi2 <- suppressWarnings(chisq.test(tab, correct = FALSE)$statistic)
  n <- sum(tab)
  k <- min(nrow(tab) - 1, ncol(tab) - 1)
  as.numeric(sqrt(chi2 / (n * k)))
}

# Matriz de pares
pairs_v <- tidyr::expand_grid(var1 = vars2, var2 = vars2) |>
  mutate(
    v = purrr::map2_dbl(var1, var2, ~ {
      d <- lesoes_ana2 |> select(all_of(c(.x, .y))) |> drop_na()
      cramers_v(d[[.x]], d[[.y]])
    })
  )

# Ordena vari√°veis por clustering para agrupar padr√µes no heatmap
mat <- pairs_v |>
  tidyr::pivot_wider(names_from = var2, values_from = v) |>
  tibble::column_to_rownames("var1") |>
  as.matrix()

mat2 <- mat
mat2[is.na(mat2)] <- 0
# diagonal = 1 para dist√¢ncia funcionar
for (i in seq_len(nrow(mat2))) mat2[i, i] <- 1

ord <- hclust(as.dist(1 - mat2))$order
vars_ord <- rownames(mat2)[ord]

pairs_v |>
  mutate(
    var1 = factor(var1, levels = vars_ord),
    var2 = factor(var2, levels = vars_ord)
  ) |>
  ggplot(aes(x = var2, y = var1, fill = v)) +
  geom_tile(color = "white", linewidth = 0.5) +
  geom_text(aes(label = ifelse(is.na(v), "", sprintf("%.2f", v))), size = 3) +
  coord_equal() +
  scale_fill_gradient(limits = c(0, 1), na.value = "white") +
  labs(
    x = NULL,
    y = NULL,
    fill = "V de Cram√©r",
    title = "Mapa de associa√ß√µes (explorat√≥rio)",
    subtitle = "For√ßa de associa√ß√£o entre vari√°veis categ√≥ricas; √∫til para escolher cruzamentos promissores"
  ) +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1),
    axis.text.y = element_text(size = 10)
  )
```

### *Heatmap*: Comorbidades √ó desfechos

```{r}
#| label: fig-heatmap-comorb-desfechos
#| fig-cap: "Heatmap explorat√≥rio: comorbidades (top 5) √ó desfechos (n√≠vel paciente), com V de Cram√©r."
#| fig-width: 9
#| fig-height: 5

# 1) Desfechos no n√≠vel PACIENTE (qualquer les√£o do paciente)
desfechos_pac <- lesoes |>
  transmute(
    paciente,
    teve_complicacao = !is.na(complicacao) & str_squish(as.character(complicacao)) != "",
    teve_reintervencao = as.logical(reintervencao) %in% TRUE,
    margem_comprometida = !is.na(margens_ap) & str_detect(margens_ap, "comprometida")
  ) |>
  group_by(paciente) |>
  summarise(
    teve_complicacao = any(teve_complicacao, na.rm = TRUE),
    teve_reintervencao = any(teve_reintervencao, na.rm = TRUE),
    margem_comprometida = any(margem_comprometida, na.rm = TRUE),
    .groups = "drop"
  )

# 2) Top 5 comorbidades por preval√™ncia (ajusta lista se quiser ‚Äúfor√ßar‚Äù quais s√£o)
comorb_cols <- c("has", "dm", "dlp", "ic", "fa", "drc", "dpoc", "alzheimer", "parkinson")
comorb_cols <- intersect(comorb_cols, names(pacientes))

top5 <- pacientes |>
  summarise(across(all_of(comorb_cols), ~ mean(.x %in% TRUE, na.rm = TRUE))) |>
  pivot_longer(everything(), names_to = "comorb", values_to = "prev") |>
  arrange(desc(prev)) |>
  slice_head(n = 5) |>
  pull(comorb)

# 3) Junta pacientes + desfechos
df <- pacientes |>
  select(paciente, all_of(top5)) |>
  left_join(desfechos_pac, by = "paciente") |>
  mutate(
    across(all_of(top5), ~ factor(.x %in% TRUE, levels = c(FALSE, TRUE), labels = c("N√£o", "Sim"))),
    across(c(teve_complicacao, teve_reintervencao, margem_comprometida),
           ~ factor(.x %in% TRUE, levels = c(FALSE, TRUE), labels = c("N√£o", "Sim")))
  )

# 4) V de Cram√©r
cramers_v <- function(x, y) {
  tab <- table(x, y, useNA = "no")
  if (nrow(tab) < 2 || ncol(tab) < 2) return(NA_real_)
  chi2 <- suppressWarnings(chisq.test(tab, correct = FALSE)$statistic)
  n <- sum(tab)
  k <- min(nrow(tab) - 1, ncol(tab) - 1)
  as.numeric(sqrt(chi2 / (n * k)))
}

desfechos <- c("teve_complicacao", "margem_comprometida", "teve_reintervencao")

m <- tidyr::expand_grid(comorb = top5, desfecho = desfechos) |>
  mutate(
    v = purrr::map2_dbl(comorb, desfecho, ~ cramers_v(df[[.x]], df[[.y]]))
  )

# 5) Heatmap retangular
m |>
  mutate(
    comorb = factor(comorb, levels = rev(top5)),
    desfecho = factor(desfecho, levels = desfechos,
                      labels = c("Complica√ß√£o", "Margem comprometida", "Reinterven√ß√£o"))
  ) |>
  ggplot(aes(x = desfecho, y = comorb, fill = v)) +
  geom_tile(color = "white", linewidth = 0.5) +
  geom_text(aes(label = ifelse(is.na(v), "", sprintf("%.2f", v))), size = 3.5) +
  scale_fill_gradient(limits = c(0, 1), na.value = "white") +
  labs(x = NULL, y = NULL, fill = "V de Cram√©r",
       title = "Comorbidades √ó desfechos",
       subtitle = "Explorat√≥rio; for√ßa de associa√ß√£o (n√≠vel paciente)") +
  theme(axis.text.x = element_text(angle = 0, hjust = 0.5))
```

Esse heatmap √© √≥timo pra identificar **vari√°veis candidatas a ajuste**. (e ele estar todo escuro √© uma boa not√≠cia: as comorbidades n√£o se associam demais aos desfechos, o que facilita a an√°lise)

::: callout-note
#### Nota metodol√≥gica

Raramente conseguimos estudar uma doen√ßa de forma isolada (ainda mais em nonagen√°rios). √â a famosa multimorbidade: al√©m de coexistirem, elas tamb√©m interagem. Isso cria um desafio anal√≠tico: muitas vari√°veis "andam juntas". Se a gente tratar tudo como independente, corremos o risco de montar um modelo que mistura esses efeitos, duplica informa√ß√£o (colinearidade) e fica dif√≠cil separar o que √© sinal do que √© eco. √â aqui que o heatmap ajuda: ele coloca, de uma vez s√≥, a matriz de associa√ß√£o entre vari√°veis (geralmente correla√ß√£o) em forma visual. A√≠ em vez de encarar uma tabela gigante de n√∫meros, a gente v√™ as zonas de calor (afinal, √© um *heat*map, rsrs) mostrando quem t√° ligado a quem com mais for√ßa. Da√≠ a gente usa isso pra guiar o pr√≥ximo passo: decidir quais vari√°veis entram juntas, quais podem ser agrupadas e quais precisam de **ajuste** quando forem relacionados ao desfecho e √† exposi√ß√£o de forma plaus√≠vel.
:::

## *Heatmap*: Tipo histol√≥gico √ó localiza√ß√£o

Aqui a ideia √© ver rapidamente **onde cada tipo histol√≥gico aparece mais**. O preenchimento do heatmap est√° em **% dentro de cada tipo (CBC/CEC)**, e o r√≥tulo mostra `n` e `%`.

```{r}
#| label: fig-heatmap-tipo-local
#| fig-cap: "Heatmap de localiza√ß√£o por tipo histol√≥gico (percentual dentro de cada tipo)."
#| fig-width: 8
#| fig-height: 5

heat_tl <- lesoes |>
  mutate(
    tipo = factor(tolower(histo_tipo), levels = c("cbc", "cec"), labels = c("CBC", "CEC")),
    local_grupo = case_when(
      localizacao == "face" ~ "Face",
      localizacao == "orelha" ~ "Orelha",
      localizacao == "couro cabeludo" ~ "Couro cabeludo",
      localizacao %in% c("t√≥rax", "dorso") ~ "Tronco",
      localizacao == "cervical" ~ "Cervical",
      str_detect(localizacao, "membro superior|antebra√ßo") ~ "Membro superior",
      str_detect(localizacao, "membro inferior|p√©") ~ "Membro inferior",
      TRUE ~ "Outro"
    ) |> factor()
  ) |>
  filter(!is.na(tipo), !is.na(local_grupo)) |>
  count(tipo, local_grupo, name = "n") |>
  group_by(tipo) |>
  mutate(
    pct_tipo = 100 * n / sum(n),
    label = sprintf("%d\n(%.0f%%)", n, pct_tipo)
  ) |>
  ungroup()

# Ordena locais pela frequ√™ncia total (mais comuns em cima)
ord_locais <- heat_tl |>
  group_by(local_grupo) |>
  summarise(n_total = sum(n), .groups = "drop") |>
  arrange(desc(n_total)) |>
  pull(local_grupo)

heat_tl |>
  mutate(local_grupo = factor(local_grupo, levels = ord_locais)) |>
  ggplot(aes(x = tipo, y = local_grupo, fill = pct_tipo)) +
  geom_tile(color = "white", linewidth = 0.6) +
  geom_text(aes(label = label), size = 3.6) +
  scale_fill_gradient(limits = c(0, 100), labels = \(x) paste0(x, "%"), na.value = "white") +
  labs(
    x = NULL,
    y = NULL,
    fill = "% dentro do tipo",
    title = "Onde est√£o CBC e CEC?",
    subtitle = "Percentual por localiza√ß√£o dentro de cada tipo histol√≥gico"
  ) +
  theme(
    axis.text.x = element_text(face = "bold"),
    axis.text.y = element_text(size = 10)
  )
```

-   Orelha: temos dados apenas de CBC

## *Heatmap*: Subtipo de CBC √ó localiza√ß√£o (VERS√ÉO BETA)

Aqui a pergunta √©: **onde cada subtipo de CBC aparece mais**. O preenchimento √© o **% dentro de cada subtipo** (ex.: ‚Äúentre os infiltrativos, quantos foram na face?‚Äù). O r√≥tulo mostra `n` e `%`.

> Nota metodol√≥gica: uma les√£o pode ter **mais de um subtipo** registrado (ex.: ‚Äúnodular, infiltrativo‚Äù). Nesse caso, ela entra em mais de uma linha do heatmap.

```{r}
#| label: fig-heatmap-subtipo-local
#| fig-cap: "Heatmap de localiza√ß√£o por subtipo de CBC (percentual dentro de cada subtipo)."
#| fig-width: 10
#| fig-height: 6

# --- prepara base ---
sub_base <- lesoes |>
  filter(tolower(histo_tipo) == "cbc") |>
  mutate(
    local_grupo = case_when(
      localizacao == "face" ~ "Face",
      localizacao == "orelha" ~ "Orelha",
      localizacao == "couro cabeludo" ~ "Couro cabeludo",
      localizacao %in% c("t√≥rax", "dorso") ~ "Tronco",
      localizacao == "cervical" ~ "Cervical",
      str_detect(localizacao, "membro superior|antebra√ßo") ~ "Membro superior",
      str_detect(localizacao, "membro inferior|p√©") ~ "Membro inferior",
      TRUE ~ "Outro"
    ) |> factor(),
    histo_subtipo = str_squish(as.character(histo_subtipo)),
    histo_subtipo = na_if(histo_subtipo, "")
  ) |>
  filter(!is.na(local_grupo), !is.na(histo_subtipo)) |>
  separate_rows(histo_subtipo, sep = ",\\s*") |>
  mutate(
    histo_subtipo = str_squish(histo_subtipo),
    histo_subtipo = str_to_sentence(histo_subtipo)
  )

# --- mant√©m top subtipos pra legibilidade ---
sub_top <- sub_base |>
  count(histo_subtipo, name = "n_total") |>
  arrange(desc(n_total)) |>
  slice_head(n = 10) |>
  pull(histo_subtipo)

heat_sl <- sub_base |>
  mutate(
    subtipo2 = if_else(histo_subtipo %in% sub_top, histo_subtipo, "Outros")
  ) |>
  count(subtipo2, local_grupo, name = "n") |>
  group_by(subtipo2) |>
  mutate(
    pct_subtipo = 100 * n / sum(n),
    label = sprintf("%d\n(%.0f%%)", n, pct_subtipo)
  ) |>
  ungroup()

# Ordena subtipos por frequ√™ncia total (mais comuns em cima)
ord_sub <- heat_sl |>
  group_by(subtipo2) |>
  summarise(n_total = sum(n), .groups = "drop") |>
  arrange(desc(n_total)) |>
  pull(subtipo2)

# Ordena locais por frequ√™ncia total
ord_loc <- heat_sl |>
  group_by(local_grupo) |>
  summarise(n_total = sum(n), .groups = "drop") |>
  arrange(desc(n_total)) |>
  pull(local_grupo)

heat_sl |>
  mutate(
    subtipo2 = factor(subtipo2, levels = ord_sub),
    local_grupo = factor(local_grupo, levels = ord_loc)
  ) |>
  ggplot(aes(x = local_grupo, y = subtipo2, fill = pct_subtipo)) +
  geom_tile(color = "white", linewidth = 0.6) +
  geom_text(aes(label = label), size = 3.2) +
  scale_fill_gradient(limits = c(0, 100), labels = \(x) paste0(x, "%"), na.value = "white") +
  labs(
    x = NULL,
    y = NULL,
    fill = "% dentro do subtipo",
    title = "Subtipos de CBC por localiza√ß√£o",
    subtitle = "Top 10 subtipos (resto agrupado como ‚ÄòOutros‚Äô)"
  ) +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1),
    axis.text.y = element_text(size = 10)
  )
```

## *Heatmap*: T√©cnica de fechamento √ó desfechos

Agora o cruzamento mais ‚Äúcl√≠nico de plant√£o‚Äù: **a t√©cnica usada pra fechar** muda o perfil de **complica√ß√£o / margens comprometidas / reinterven√ß√£o**?

O preenchimento aqui √© o **% dentro de cada t√©cnica** (ex.: entre os retalhos, qual % complicou?). O r√≥tulo mostra `n` e `%`.

```{r}
#| label: fig-heatmap-fech-desfechos
#| fig-cap: "Heatmap de desfechos por t√©cnica de fechamento (percentual dentro de cada t√©cnica)."
#| fig-width: 10
#| fig-height: 5

fech_levels <- c("Fechamento direto", "Enxerto", "Retalho", "Segunda inten√ß√£o")

fd <- lesoes |>
  mutate(
    fech_label = case_when(
      fech == "direto" ~ "Fechamento direto",
      fech == "retalho" ~ "Retalho",
      fech == "enxerto" ~ "Enxerto",
      fech == "2intencao" ~ "Segunda inten√ß√£o",
      TRUE ~ as.character(fech)
    ) |> factor(levels = fech_levels),

    teve_complicacao = !is.na(complicacao) & str_squish(as.character(complicacao)) != "",
    teve_reintervencao = as.logical(reintervencao) %in% TRUE,

    # Margens: mant√©m NA como NA (porque nem toda les√£o tem esse dado preenchido)
    margem_comprometida = case_when(
      is.na(margens_ap) ~ NA,
      str_detect(margens_ap, "comprometida") ~ TRUE,
      margens_ap == "livres" ~ FALSE,
      TRUE ~ NA
    )
  ) |>
  filter(!is.na(fech_label)) |>
  select(fech_label, teve_complicacao, margem_comprometida, teve_reintervencao)

long <- fd |>
  pivot_longer(
    cols = c(teve_complicacao, margem_comprometida, teve_reintervencao),
    names_to = "desfecho",
    values_to = "valor"
  ) |>
  mutate(
    desfecho = factor(
      desfecho,
      levels = c("teve_complicacao", "margem_comprometida", "teve_reintervencao"),
      labels = c("Complica√ß√£o", "Margem comprometida", "Reinterven√ß√£o")
    )
  )

heat_fd <- long |>
  group_by(fech_label, desfecho) |>
  summarise(
    n_sim = sum(valor %in% TRUE, na.rm = TRUE),
    n_denom = sum(!is.na(valor)),
    pct = if_else(n_denom > 0, 100 * n_sim / n_denom, NA_real_),
    label = if_else(n_denom > 0, sprintf("%d\n(%.0f%%)", n_sim, pct), ""),
    .groups = "drop"
  )

heat_fd |>
  ggplot(aes(x = desfecho, y = fech_label, fill = pct)) +
  geom_tile(color = "white", linewidth = 0.6) +
  geom_text(aes(label = label), size = 3.4) +
  scale_fill_gradient(limits = c(0, 100), labels = \(x) paste0(x, "%"), na.value = "white") +
  labs(
    x = NULL,
    y = NULL,
    fill = "% dentro da t√©cnica",
    title = "Desfechos por t√©cnica de fechamento",
    subtitle = "Denominador = les√µes com desfecho preenchido (margens pode ter NA)"
  ) +
  theme(
    axis.text.x = element_text(face = "bold"),
    axis.text.y = element_text(size = 10)
  )
```

## *Heatmap*: Subtipo (CBC) / comportamento (CEC) √ó margens

Aqui a pergunta √© bem direta: **quais perfis histol√≥gicos tendem a ter mais margem comprometida**?

-   Para **CBC**, usamos **subtipos** (lembrando que uma les√£o pode ter mais de um subtipo).
-   Para **CEC**, usamos **comportamento**.

O preenchimento do heatmap √© o **% dentro de cada subtipo/comportamento** (ex.: ‚Äúentre os infiltrativos, quantos % tiveram margem comprometida?‚Äù). O r√≥tulo mostra `n` e `%`.

### CBC: subtipo √ó margens

```{r}
#| label: fig-heatmap-subtipo-margens
#| fig-cap: "Heatmap de margens por subtipo de CBC (percentual dentro de cada subtipo)."
#| fig-width: 10
#| fig-height: 6

cbc_base <- lesoes |>
  filter(tolower(histo_tipo) == "cbc") |>
  mutate(
    margens_status = case_when(
      is.na(margens_ap) ~ NA_character_,
      str_detect(margens_ap, "comprometida") ~ "Comprometidas",
      margens_ap == "livres" ~ "Livres",
      TRUE ~ "Outro"
    ) |> factor(levels = c("Livres", "Comprometidas", "Outro")),
    histo_subtipo = str_squish(as.character(histo_subtipo)),
    histo_subtipo = na_if(histo_subtipo, "")
  ) |>
  filter(!is.na(margens_status), !is.na(histo_subtipo)) |>
  separate_rows(histo_subtipo, sep = ",\\s*") |>
  mutate(
    histo_subtipo = str_squish(histo_subtipo),
    histo_subtipo = str_to_sentence(histo_subtipo)
  )

# Top 10 subtipos (resto = Outros)
sub_top2 <- cbc_base |>
  count(histo_subtipo, name = "n_total") |>
  arrange(desc(n_total)) |>
  slice_head(n = 10) |>
  pull(histo_subtipo)

heat_sm <- cbc_base |>
  mutate(subtipo2 = if_else(histo_subtipo %in% sub_top2, histo_subtipo, "Outros")) |>
  count(subtipo2, margens_status, name = "n") |>
  group_by(subtipo2) |>
  mutate(
    pct = 100 * n / sum(n),
    label = sprintf("%d\n(%.0f%%)", n, pct)
  ) |>
  ungroup()

ord_sub2 <- heat_sm |>
  group_by(subtipo2) |>
  summarise(n_total = sum(n), .groups = "drop") |>
  arrange(desc(n_total)) |>
  pull(subtipo2)

heat_sm |>
  mutate(subtipo2 = factor(subtipo2, levels = ord_sub2)) |>
  ggplot(aes(x = margens_status, y = subtipo2, fill = pct)) +
  geom_tile(color = "white", linewidth = 0.6) +
  geom_text(aes(label = label), size = 3.2) +
  scale_fill_gradient(limits = c(0, 100), labels = \(x) paste0(x, "%"), na.value = "white") +
  labs(
    x = NULL,
    y = NULL,
    fill = "% dentro do subtipo",
    title = "CBC: margens por subtipo",
    subtitle = "Top 10 subtipos (resto agrupado como ‚ÄòOutros‚Äô)"
  ) +
  theme(
    axis.text.x = element_text(face = "bold"),
    axis.text.y = element_text(size = 10)
  )
```

### CEC: comportamento √ó margens

```{r}
#| label: fig-heatmap-comport-margens
#| fig-cap: "Heatmap de margens por comportamento de CEC (percentual dentro de cada comportamento)."
#| fig-width: 8
#| fig-height: 4.8

cec_base <- lesoes |>
  filter(tolower(histo_tipo) == "cec") |>
  mutate(
    margens_status = case_when(
      is.na(margens_ap) ~ NA_character_,
      str_detect(margens_ap, "comprometida") ~ "Comprometidas",
      margens_ap == "livres" ~ "Livres",
      TRUE ~ "Outro"
    ) |> factor(levels = c("Livres", "Comprometidas", "Outro")),
    comportamento = str_squish(as.character(comport)),
    comportamento = na_if(comportamento, "")
  ) |>
  filter(!is.na(margens_status), !is.na(comportamento)) |>
  mutate(comportamento = str_to_sentence(comportamento))

heat_cm <- cec_base |>
  count(comportamento, margens_status, name = "n") |>
  group_by(comportamento) |>
  mutate(
    pct = 100 * n / sum(n),
    label = sprintf("%d\n(%.0f%%)", n, pct)
  ) |>
  ungroup()

ord_comp <- heat_cm |>
  group_by(comportamento) |>
  summarise(n_total = sum(n), .groups = "drop") |>
  arrange(desc(n_total)) |>
  pull(comportamento)

heat_cm |>
  mutate(comportamento = factor(comportamento, levels = ord_comp)) |>
  ggplot(aes(x = margens_status, y = comportamento, fill = pct)) +
  geom_tile(color = "white", linewidth = 0.6) +
  geom_text(aes(label = label), size = 3.4) +
  scale_fill_gradient(limits = c(0, 100), labels = \(x) paste0(x, "%"), na.value = "white") +
  labs(
    x = NULL,
    y = NULL,
    fill = "% dentro do comportamento",
    title = "CEC: margens por comportamento",
    subtitle = "Percentual de margens por categoria de comportamento"
  ) +
  theme(
    axis.text.x = element_text(face = "bold"),
    axis.text.y = element_text(size = 10)
  )
```
::: callout-important
#### Pera a√≠... Algo de errado n√£o est√° certo!

Esse heatmap parece dizer que CEC invasivo √© ‚Äúmais f√°cil‚Äù de ressecar com margem livre do que o in situ‚Ä¶ o que biologicamente n√£o faz muito sentido como regra geral. Acredito que a explica√ß√£o mais prov√°vel t√° no processo (sele√ß√£o + conduta), n√£o na natureza do tumor. Algumas hip√≥teses:

1.  Conduta cir√∫rgica mais ‚Äúgenerosa‚Äù no invasivo: Quando a les√£o √© suspeita de invas√£o, as margens s√£o maiores (ou as t√©cnicas s√£o mais cuidadosas... Sei l√°, eu n√£o opero ningu√©m)
2.  Vi√©s de sele√ß√£o: Se o banco pega quem foi operado e tem AP, pode ter um "filtro". Do tipo: CEC invasivo muito extenso pode nem ter ido pra cirurgia (ou foi encaminhado pra outro servi√ßo), ent√£o s√£o selecionados os invasivos *oper√°veis* e *ressec√°veis* que naturalmente t√™m mais margens livres.
3.  Denominador pequeno = instabilidade: Se o n√∫mero de les√µes em certas categorias for pequeno, o percentual pode oscilar bastante. Com um N assim, uma margem comprometida a mais j√° derruba esse 95%.
4.  Como a vari√°vel "margem" foi registrada? √Äs vezes "margens livres" √© o status final depois de reabordagem, e a√≠ "margens comprometidas" vira um evento intermedi√°rio que n√£o aparece.
:::

------------------------------------------------------------------------

*Gerado em `r format(Sys.time(), "%d/%m/%Y √†s %H:%M")`*
